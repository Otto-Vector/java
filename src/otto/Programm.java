package otto;

import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;

import Monsters.Elements;//присоединение класса Elements из соседнего пакета Monsters

public class Programm {

	public static void main(String[] args) {
		
		

		String[] Names = {"Василий","Анатолий","Константин","Мохнатый","Белый","Виктор","Николай","Антон",
				"Павел","Прохор","Никита","Перчик","Соня","Виталий","Анастасия","Лютик","Миха",
				"Робот","Килуа","Селедка","Пилка","Боня","Илья","Мася","Джонни"};

		Elements[] n = new Elements[Names.length]; //создание массива типа Elements в зависимости от количества созданных имён
		Elements[] nReit = new Elements[Names.length]; //создание массива типа Elements для рейтинга
		
		StringBuilder AtkOutput = new StringBuilder(); //переменная для построения данных о выводе атаки
		List<String> Statistic = new ArrayList<String>(); //массив, куда будут записываться данные об атаках из переменной AtkOutput
		
		for (int i=0; i<Names.length; i++) 
		{//присвоение имён по порядку и случайных элементов, в виде числа от (0 до 4)
			n[i]= new Elements(Names[i],(int)(Math.random()*5),(int)(Math.random()*5));//вызов конструктора для присвоения значений элементам массива
		}

		int i,j, //переменные нападающего и защищающегося монстра
			Alive, //переменная для подсчёта выживших
			kick, //переменная для подсчёта урона
			job;//переменная, которой присваивается значение сработавшего или нет 


		do { //запуск основного цикла для сталкивания мобов
			
			Alive=0; //обнуление значения выживших
			for (Elements g : n) if (g.getHP()>0) Alive++; //подсчёт выживших по положительному коэфициэнту ХП

				i=(int)(Math.random()*Names.length);
				j=(int)(Math.random()*Names.length); //случайные числа для выбора нападающего и защищающегося моба
			
				if ((i != j) && n[i].getHP()>0 && n[j].getHP()>0) //если элемент не является самим собой и если оба живы
				{
						
			boolean fireSkill; //объявление метки выхода из массива
			do // этот цикл вместе с поинтером fireSkill запускается до тех пор, пока на элементе "огонь" срабатывает навык ответной атаки
			
			{ 	fireSkill=false;
			
				AtkOutput.delete(0, AtkOutput.capacity()); //обнуление стрингбилдера, который формирует вывод атак на экран
			
					kick=n[j].getHP(); //начальное значение ХП жертвы до атаки для подсчёта урона
						job=Elements.Attack(n[i], n[j]);//активация атаки и присвоение значения атаки переменной
							kick-=n[j].getHP();//присвоение переменной разницы в ХП до и после атаки, вычисляя значение урона
					
					AtkOutput.append(n[i].getName()+"."+n[i].getHP()+"("+n[i].getLvl()+") напал на "+n[j].getName()+"."+n[j].getHP()+"("+n[j].getLvl()+"), -"+kick+" пт.");

					if (job > 0) //добавление данных параметров атаки в зависимости от того сработала крит-атака элементов или нет
						{
						AtkOutput.append(" (АТАКА "+n[i].getElAtk()+"-"+n[j].getElDef()+")");
						}
					else if (job < 0) //формирование строки параметров атаки в зависимости от того сработала защита элементов или нет
						{
						AtkOutput.append(" (Защита "+n[i].getElAtk()+"-"+n[j].getElDef()+")");
						}
					System.out.println(AtkOutput); // вывод данных сформированной строки атаки
					
					Statistic.add(AtkOutput.toString()); //добавление данных в "массив" статистики только атак, без скилов
					
					if ((n[j].getHP()>0) && (n[j].getElDef()=="Fire") && n[j].Chancer(n[j].getChance()))
						//если огненный защитник остался в живых и срабатывает Сhancer/вычислитель шанса/, то нападающий и жертва меняются местами,
						//а поинтеру присваивается значение "истина"
					{i^=j; j^=i; i^=j; // способ поменять целочисленные значения без буферной переменной
					fireSkill=true; System.out.print("+ог-");}
			}
			while (fireSkill); //окончание цикла работы скила ответной атаки
			
				if (n[j].getHP()<=0) //если элемент, на который напали побеждён
					{
					System.out.println("# "+n[j].getName()+" Выбыл! "+"осталось ("+(Alive-1)+")");
					nReit[Alive-1]=n[j]; //здесь присваиваются значения в порядке вылета, но без победителя, победитель присваивается за циклом
					Elements.lvlUp(n[i]); //происходит поднятие уровня победителя и вывод информации на экран
					System.out.println("$$"+n[i].getName()+ " поднял уровень до "+n[i].getLvl());
					}
				}
			}
		while (Alive>=2); //выполнение цикла пока выживших Alive двое
		
		System.out.println("________________________________________");//полоса подведения итогов
		
		for (Elements g : n)
			if (g.getHP()>0)
			{ //перебор значения HP и вывод на экран имени победителя
				System.out.println("Победитель: "+g.getName()+"!!! ");
				nReit[0]=g; //здесь присваивается значение победителя для дальнейшего перебора на выводе
			}

		String sss;//переменная для работы с вводом данных в цикле и выборки значений по номеру монстра в рейтинга
		j = 1;//присваивается значение "1" для того чтобы не сработало окно "ошибка ввода", повторное использование переменной, объявленной в начале программы
		boolean mark = false;
		do
		{
			
			System.out.println("\n\t\tРЕЙТИНГ БОЙЦОВ (в порядке выбывания):");

		i=0; //обнуление i для присвоения его данных в выводе рейтинга, повторное использование переменной, объявленной в начале программы
		for (Elements g: nReit)
			{
			System.out.printf("#%2d",++i);
			g.ShowMonster(); //вывод на экран всех рейтинга и данных о монстрах после битвы
			}
				
            if (j<=0 || j>(nReit.length)) JOptionPane.showMessageDialog(null,"Введите корректное число (1-"+nReit.length+")!", "Ошибка ввода", 0);
        sss = JOptionPane.showInputDialog(null, "Введите номер монстра:", JOptionPane.INFORMATION_MESSAGE);
        if (sss==null || sss.equals("") || !sss.matches("[+-]?\\d+")) mark = false; //если значение не число или панельку закрыли, маркируется выход
        	else
        	{
        	 j = Integer.parseInt(sss); mark=true; //перевод строки в число, маркируется следующий цикл, для просмотра данных другого моба
         
        	 if (j>0 && j<=(nReit.length)) //если число количественно совпадает с номером в массиве рейтинга
        	 {

        		 for (String s: Statistic)
        			 if ( s.contains(nReit[(j-1)].getName()))  //поиск строки, включающей в себя имя "монстра"
        				 // && s.indexOf(nReit[(j-1)].getName()) == 0 //это поиск, если данное имя в начале, т.е. выборка только атак
        				 System.out.println(s);
        	 }
        	}
   		}
		while(mark);
	}

}
